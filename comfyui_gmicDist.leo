<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="albercio.20240212100312.2"><vh>Control Panel</vh>
<v t="albercio2.20240212102158.1"><vh>Side Bar</vh>
<v t="albercio2.20240212102206.1"><vh>Contents Sidebar</vh></v>
</v>
</v>
<v t="albercio2.20240212101047.1"><vh>Startup</vh>
<v t="albercio2.20240212172356.1"><vh>@settings</vh>
<v t="albercio2.20240212101145.1"><vh>@bool run-flake8-on-write = False</vh></v>
<v t="albercio2.20240212172037.1"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="albercio2.20240212172041.1"><vh>@data exec-script-commands</vh></v>
<v t="albercio2.20240212172045.1"><vh>@data exec-script-patterns</vh></v>
<v t="albercio2.20240212172100.1"><vh>@data history-list</vh></v>
<v t="albercio2.20240212172106.1"><vh>@int fts_max_hits = 100</vh></v>
<v t="albercio2.20240212101137.1"><vh>@string target_language = python</vh></v>
<v t="albercio2.20240212101202.1"><vh>Beautify command settings</vh>
<v t="albercio2.20240212101202.2"><vh>@bool beautify-allow-joined-strings = False</vh></v>
<v t="albercio2.20240212101202.3"><vh>@bool beautify-keep-comment-indentation = True</vh></v>
<v t="albercio2.20240212101202.4"><vh>@int beautify-max-join-line-length = 0</vh></v>
<v t="albercio2.20240212101202.5"><vh>@int beautify-max-split-line-length = 0</vh></v>
<v t="albercio2.20240212101306.1"><vh>Buttons &amp; commands</vh>
<v t="albercio2.20240212100758.3"><vh>button summrz</vh>
<v t="albercio2.20240212100758.4"><vh>init</vh></v>
</v>
<v t="albercio2.20240212100758.7"><vh>@button del-editor</vh></v>
<v t="albercio2.20240212100758.6"><vh>@button add-editor</vh></v>
<v t="albercio2.20240212101306.2"><vh>@button backup</vh></v>
<v t="albercio2.20240212101306.3"><vh>@button backup-repo</vh></v>
<v t="albercio2.20240212101306.7"><vh>@command pwd</vh></v>
<v t="albercio2.20240212101306.9"><vh>Unused buttons</vh>
<v t="albercio2.20240212101306.43"><vh>@@button pep8 @key=Ctrl-5</vh>
<v t="albercio2.20240212101306.44"><vh>class Pep8</vh>
<v t="albercio2.20240212101306.45"><vh>change_all &amp; helpers</vh>
<v t="albercio2.20240212101306.46"><vh>change_body</vh></v>
<v t="albercio2.20240212101306.47"><vh>change_headline</vh></v>
</v>
<v t="albercio2.20240212101306.48"><vh>get_name</vh></v>
<v t="albercio2.20240212101306.49"><vh>run</vh></v>
<v t="albercio2.20240212101306.50"><vh>to_pep8</vh></v>
</v>
<v t="albercio2.20240212101306.51"><vh>clear</vh></v>
</v>
<v t="albercio2.20240212101306.52"><vh>@@button run-pylint</vh></v>
<v t="albercio2.20240212101306.53"><vh>@@button show-gnx</vh></v>
</v>
</v>
</v>
</v>
<v t="albercio2.20240212172345.1"><vh>scripts</vh>
<v t="albercio2.20240212172345.5"><vh>script: check gnx's</vh></v>
<v t="albercio2.20240212172345.6"><vh>script: check gnxDict</vh></v>
<v t="albercio2.20240212172345.16"><vh>script: diff-two-revs-wo-comments</vh>
<v t="albercio2.20240212172345.17"><vh>function: make_diff_outlines_ignoring_comments</vh></v>
<v t="albercio2.20240212172345.18"><vh>function: strip_comments</vh></v>
</v>
<v t="albercio2.20240212172345.19"><vh>script: find trailing comments</vh></v>
</v>
</v>
<v t="albercio2.20240212102036.1"><vh>Notes</vh>
<v t="albercio2.20240212173101.1"><vh>**Todo</vh></v>
<v t="albercio2.20240212173936.3"><vh>Reading</vh></v>
</v>
<v t="albercio2.20240212173143.1"><vh>Distribution files</vh>
<v t="albercio2.20240212173246.2"><vh>@clean .gitignore</vh></v>
<v t="albercio2.20240212173530.2"><vh>@clean LICENSE</vh></v>
<v t="albercio2.20240216183954.1"><vh>@auto README.md</vh></v>
</v>
<v t="albercio2.20240212174045.1"><vh>Code</vh>
<v t="albercio2.20240212174732.1"><vh>@clean __init__.py</vh>
<v t="albercio2.20240212174732.2"><vh>&lt;&lt; import &gt;&gt;</vh></v>
</v>
<v t="albercio2.20240212174846.1"><vh>@clean comfy_gmic.py</vh>
<v t="albercio2.20240212174846.2"><vh>&lt;&lt; import &gt;&gt;</vh></v>
<v t="albercio2.20240212174846.3"><vh>class GmicCliWrapper</vh>
<v t="albercio2.20240212174846.4"><vh>INPUT_TYPES</vh></v>
<v t="albercio2.20240212174846.5"><vh>RETURN_TYPES</vh></v>
<v t="albercio2.20240212174846.6"><vh>gmic_filter</vh></v>
</v>
<v t="albercio2.20240212174846.7"><vh>NODE_CLASS_MAPPINGS</vh></v>
</v>
</v>
<v t="albercio2.20240216135957.1"><vh>Recent code</vh>
<v t="albercio2.20240216140122.1"><vh>PR</vh></v>
<v t="albercio2.20240216184208.1"><vh>git diff revs: 7548ef2 main</vh>
<v t="albercio2.20240216184208.2"><vh>diff: comfy_gmic.py</vh>
<v t="albercio2.20240216184208.19"><vh>Changed</vh>
<v t="albercio2.20240216184208.20"><vh>&lt;&lt; import &gt;&gt;</vh>
<v t="albercio2.20240216184208.21"><vh>Old:&lt;&lt; import &gt;&gt;</vh></v>
<v t="albercio2.20240212174846.2"></v>
</v>
<v t="albercio2.20240216184208.22"><vh>class GmicCliWrapper</vh>
<v t="albercio2.20240216184208.23"><vh>Old:class GmicCliWrapper</vh></v>
<v t="albercio2.20240212174846.3"></v>
</v>
<v t="albercio2.20240216184208.24"><vh>INPUT_TYPES</vh>
<v t="albercio2.20240216184208.25"><vh>Old:INPUT_TYPES</vh></v>
<v t="albercio2.20240212174846.4"></v>
</v>
<v t="albercio2.20240216184208.26"><vh>RETURN_TYPES</vh>
<v t="albercio2.20240216184208.27"><vh>Old:RETURN_TYPES</vh></v>
<v t="albercio2.20240212174846.5"></v>
</v>
<v t="albercio2.20240216184208.28"><vh>gmic_filter</vh>
<v t="albercio2.20240216184208.29"><vh>Old:gmic_filter</vh></v>
<v t="albercio2.20240212174846.6"></v>
</v>
<v t="albercio2.20240216184208.30"><vh>NODE_CLASS_MAPPINGS</vh>
<v t="albercio2.20240216184208.31"><vh>Old:NODE_CLASS_MAPPINGS</vh></v>
<v t="albercio2.20240212174846.7"></v>
</v>
</v>
</v>
</v>
</v>
<v t="albercio2.20240212173936.1"><vh>Learn</vh>
<v t="albercio2.20240216135810.1"><vh>Idea</vh></v>
<v t="albercio2.20240212173936.2"><vh>Next</vh></v>
<v t="albercio2.20240212173936.3"></v>
</v>
</vnodes>
<tnodes>
<t tx="albercio.20240212100312.2"></t>
<t tx="albercio2.20240212100758.3">@language python
@tabwidth 8
"""
'''@1 make tree nodes of indent '''
    '''Take current body.'''
        '''parse indent'''
            '''headline and body (&amp;all child)'''
                '''Copy to the parent's body text. &gt;@1'''
"""
@others
</t>
<t tx="albercio2.20240212100758.4">@language python
c.frame.log.clearLog()
print = g.es

lst = g.splitLines(c.p.b)

result = []
current_headline = ''
current_body = ''

for item in lst:
    if item[0].isalpha() and '\t' not in item:
        if current_headline != '':
            result.append((current_headline.strip(), current_body.strip()))
        current_headline = item.strip()
        current_body = ''
    
    elif item.startswith('\t'):
        current_body += item.strip() + '\n'
    
    elif item == '\n':
        continue
    
if current_headline != '':
    result.append((current_headline.strip(), current_body.strip()))

parent = c.currentPosition().insertAsLastChild()
parent.h = 'Summary'
table = result
for headline, body in table:
    child = parent.insertAsLastChild()
    child.b = body.rstrip() + '\n'
    child.h = headline
c.selectPosition(parent)
c.redraw()



"""

"""</t>
<t tx="albercio2.20240212100758.6">@language python
c.frame.log.clearLog()
print = g.es

c.executeMinibufferCommand('add-editor')
</t>
<t tx="albercio2.20240212100758.7">@language python
c.frame.log.clearLog()
print = g.es

c.executeMinibufferCommand('delete-editor')
</t>
<t tx="albercio2.20240212101047.1"></t>
<t tx="albercio2.20240212101137.1">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="albercio2.20240212101145.1"># See flake8 settings in setup.cfg.</t>
<t tx="albercio2.20240212101202.1"></t>
<t tx="albercio2.20240212101202.2">True:  allow joined lines to contain strings.
False: (Recommended by EKR): Retain alignment of strings.</t>
<t tx="albercio2.20240212101202.3">True: Retain indentation of overindented stand-alone comment lines.</t>
<t tx="albercio2.20240212101202.4"># At present I am of the opinion that joining lines is usually a bad idea.

Should be &lt;= beautify-max-split-line-length.
Zero suppresses all line joining.</t>
<t tx="albercio2.20240212101202.5">Zero suppresses all line splitting.</t>
<t tx="albercio2.20240212101306.1">@language python
</t>
<t tx="albercio2.20240212101306.2">"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='leoPy')
</t>
<t tx="albercio2.20240212101306.3">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = os.getcwd()
if win:
    new_dir = r'C:\Repos\ComfyUI_GMIC'
    path = r'C:\Repos\Backup'
else:
    new_dir = '/home/edward/Repos/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, f"leo-bundle-all-{stamp}")
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="albercio2.20240212101306.43">"""Converts the word at the cursor to pep8 style throughout a given tree."""
# aTestExample notFoundExample.
import re
# clear()
table = (
    # 'BLS.new_scan',
    # 'BLS.Code generation',
    # 'class Importer',
)
@others
Pep8(table, change=True).run()
</t>
<t tx="albercio2.20240212101306.44">class Pep8:
    """
    Convert the word under the cursor to pep8 style in all subtrees in
    table.
    """
    
    def __init__ (self, table, change=False):
        """Ctor for Pep8 class."""
        self.change = change
        self.table = table
        
    @others
</t>
<t tx="albercio2.20240212101306.45">def change_all(self, name, new_name, root):
    """Change name to new_name throughout root's tree."""
    u = c.undoer
    bunch = u.beforeChangeTree(root)
    found = False
    self.pattern = re.compile(r'\b%s\b' % name)
    for p in root.self_and_subtree():
        found = self.change_headline(name, new_name, p) or found
        found = self.change_body(name, new_name, p) or found
    if found:
        u.afterChangeTree(root, 'pep8', bunch)
    return found
</t>
<t tx="albercio2.20240212101306.46">def change_body(self, name, new_name, p):
    indices = []
    for m in self.pattern.finditer(p.b):
        indices.append(str(m.start()))
    if indices:
        n = len(indices)
        g.es_print('%s change%s: %s' % (n, g.plural(n), p.h))
        s = p.b
        for i in reversed(indices):
            i = int(i)
            s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.b = s
            p.setDirty()
        else:
            g.es_print(s)
    return bool(indices)</t>
<t tx="albercio2.20240212101306.47">def change_headline(self, name, new_name, p):
    m = self.pattern.search(p.h)
    if m:
        i = m.start()
        s = p.h
        s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.h = s
            p.setDirty()
            g.es_print('changed headline', s)
        else:
            g.es_print('headline', s)
    return bool(m)
</t>
<t tx="albercio2.20240212101306.48">def get_name(self):
    i, j = c.editCommands.extendToWord(event=None, select=False)
    w = c.frame.body.wrapper
    s = w.getAllText()
    name = s[i:j]
    return name
</t>
<t tx="albercio2.20240212101306.49">def run(self):
    # self.clear()
    name = self.get_name()
    new_name = self.to_pep8(name)
    if len(name) &lt; 2:
        g.es_print('name too short:', name)
    elif new_name == name:
        g.es_print('already pep8:', name)
    else:
        g.es_print('%s -&gt; %s' % (name, new_name))
        # Preload the replacement text.
        c.findCommands.ftm.set_find_text(new_name)
        found = False
        for target in table:
            root = g.findNodeAnywhere(c, target)
            if root:
                found = self.change_all(name, new_name, root) or found
            else:
                g.es_print('not found: %s' % target)
        if found:
            c.redraw()
        else:
            g.es_print('not found:', name)
</t>
<t tx="albercio2.20240212101306.50">def to_pep8(self, s):
    
    if len(s) &gt; 1 and s[0].islower() and s.lower() != s:
        result = []
        for ch in s:
            result.append(ch)
            if ch.isupper():
                result.pop()
                result.append('_%s' % (ch.lower()))
        return ''.join(result)
    else:
        return name</t>
<t tx="albercio2.20240212101306.51">def clear():
    g.cls()
    c.k.simulateCommand('clear-log')
</t>
<t tx="albercio2.20240212101306.52">@language python

"""myLeoSettings.py: save the outline and run the pylint command"""

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="albercio2.20240212101306.53">print(p.gnx)</t>
<t tx="albercio2.20240212101306.7">import os
print(f"\nos.curdir: {os.path.abspath(os.curdir)}")</t>
<t tx="albercio2.20240212101306.9"></t>
<t tx="albercio2.20240212102036.1"></t>
<t tx="albercio2.20240212102158.1"></t>
<t tx="albercio2.20240212102206.1"></t>
<t tx="albercio2.20240212172037.1"></t>
<t tx="albercio2.20240212172041.1"># This node contains the commands needed to execute a program in a particular language.
# Format: language-name: command

#
# execute-general-script always creates a temporary file.
# Just before executing the command, execute-general-script
# Replaces &lt;FILE&gt; by the name of the temporary file.

# This does work.
# python: python -v &lt;FILE&gt;

go: go run .
python: python
rust: rustc
</t>
<t tx="albercio2.20240212172045.1"># This node contains the regex pattern to determine the line number in error messages.
# Format: language-name: regex pattern
#
# Patterns must define two groups, in either order:
# One group, containing only digits, defines the line number.
# The other group defines the file name.


go ^\s*(.*):([0-9]+):([0-9]+):.+$
python: ^\s*File "(.+)", line ([0-9]+), in .+$
rust: ^\s*--&gt; (.+):([0-9]+):([0-9]+)\s*$</t>
<t tx="albercio2.20240212172100.1">beautify-files
expand-all-subheads
pylint
backup
show-commands
show-bindings</t>
<t tx="albercio2.20240212172106.1"></t>
<t tx="albercio2.20240212172345.1"></t>
<t tx="albercio2.20240212172345.16">g.cls()

# Monkey-patched git-diff-pr command.
import leo.commands.editFileCommands as efc

rev1 = '7548ef2'
rev2 = 'main'
x = efc.GitDiffController(c)

@others

# Monkey-patch, with x bound.
x.make_diff_outlines = make_diff_outlines_ignoring_comments
x.diff_two_revs(rev1, rev2)


</t>
<t tx="albercio2.20240212172345.17">def make_diff_outlines_ignoring_comments(c1, c2, fn, rev1='', rev2=''):
    """Create an outline-oriented diff from the *hidden* outlines c1 and c2."""
    self = x
    added, deleted, changed = self.compute_dicts(c1, c2)
    table = (
        (added, 'Added'),
        (deleted, 'Deleted'),
        (changed, 'Changed'))
    for d, kind in table:
        if kind.lower() == 'changed':
            for key in d:
                v1, v2 = d.get(key)
                v1.b = strip_comments(v1.b)
                v2.b = strip_comments(v2.b)
        self.create_compare_node(c1, c2, d, kind, rev1, rev2)
</t>
<t tx="albercio2.20240212172345.18">def strip_comments(aString):
    """
    Strip everything that looks like a comment from aString.
    It's fine, for now, to ignore strings and docstrings.
    """
    result = []
    lines = g.splitLines(aString)
    for s in lines:
        if s.strip().startswith('#@'):
            # Retain everything that looks like a sentinel.
            result.append(s)
        else:
            # Strip the comment, ignoring the end of the line.
            i = s.find('#')
            if i == -1:
                result.append(s)
            else:
                tail = s[:i]
                if tail.strip():
                    result.append(tail.rstrip() + '\n')
    return ''.join(result)
</t>
<t tx="albercio2.20240212172345.19">"""
Find and mark all nodes containing underindented trailing comments in c's outline.

Such comments have the form:
    
    .. some code ..
        A trailing, overindented comment.
"""
g.cls()
import re
pattern = re.compile(r'\w+\s*=\s\w+')

def do_node(p):
    global count
    prev_assign = False
    old_lws = 0
    lines = g.splitLines(p.b)
    for i, line in enumerate(lines):
        lws = g.computeLeadingWhitespaceWidth(line, tab_width=-4)
        if line.strip().startswith('#'):
            if prev_assign and lws &gt; old_lws:
                # Found a likely trailing comment.
                p.setMarked()
                count += 1
                return True
            prev_assign = False
        else:
            old_lws = lws
            prev_assign = pattern.search(line)
    return False
    
count = 0
c.clearAllMarked()
for p in c.all_unique_positions():
    do_node(p)
print(f"found {count} nodes.")
</t>
<t tx="albercio2.20240212172345.5">d = {}  # Keys are gnxs, values is a list of vnodes with that gnx.
for v in c.all_nodes():
    gnx = v.gnx
    aList = d.get(gnx, [])
    if v not in aList:
        aList.append(v)
        d [gnx] = aList
        if len(aList) &gt; 1:
            print(f"gnx clash: {gnx}")
            g.printObj(aList)
print('done')</t>
<t tx="albercio2.20240212172345.6">g.cls()
fc = c.fileCommands
d = fc.gnxDict
for key in sorted(d.keys()):
    v = d.get(key)
    if v.h.lower() == 'newheadline':
        print('in dict', key, v)
        for p in c.all_positions():
            if p.v == v:
                print(p)
        else:
            print('no position for', v)
print('done')</t>
<t tx="albercio2.20240212172356.1"></t>
<t tx="albercio2.20240212173101.1">
[ ] Batch image
[ ] Favorites drop-down for easier usage


--

[v] test leo git integration




</t>
<t tx="albercio2.20240212173143.1"></t>
<t tx="albercio2.20240212173246.2">@language unknown_language
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/
</t>
<t tx="albercio2.20240212173530.2">@language unknown_language
MIT License

Copyright (c) 2023 Tumpal Gemelli

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</t>
<t tx="albercio2.20240212173936.1">@language rest
@nowrap</t>
<t tx="albercio2.20240212173936.2">

Lit
    AboutGmicGuiFiltersParser.md
    Export G'MIC filters description to a JSON file · GitHub.html
    Funny Oneliners.html
    Developing, compiling, testing, releasing — gmic-py 2.9.4-alpha1_ documentation.html
    Quickstart — gmic-py 2.9.4-alpha1_ documentation.html#working-with-the-numpy-support
    Windows support · Issue #88 · myselfhimself_gmic-py · GitHub.html
    About G'MIC's _fx__ and ___ prefixed filters or commands · GitHub .html
    man gmic (1)_ Perform generic image processing operations, through the G'MIC language interpreter.
    /Tutorial
        Images as Data Sets
    ---First
        Input_Output Properties.html
        Input Data.html
        input.shtml
        Substitution Rules
        Riffs
        Finger Exercises
    ---Numpy
        Scikit-Image support — gmic-py 2.9.4-alpha1_ documentation (1_31_2024 6_05_00 PM).html
        API Reference — gmic-py 2.9.4-alpha1_ documentation (1_31_2024 6_04_47 PM)
        Add native I_O support for numpy arrays as image types · Issue #28 · myselfhimself_gmic-py · GitHub
        Add Numpy, PIL, Scikit-Image support · Issue #59 · myselfhimself_gmic-py · GitHub.html


Script
    test_gmic_py_filters_io.py
    /gmic-filters-default-parameters-to-operators
    /gmic-py
    /pycimg

Data
    filters290.json
    out.json
    diffellipse.gmic

Commands
    eigen
    svd
    fitsamples
    nn_conv2d ..
    filename_rand
    normalize_filename
    std_noise
    Do Your Own Diffusion Tensor Fields.html</t>
<t tx="albercio2.20240212173936.3">

pycimg/README.rst
    Pixel data of CImg objects can be accessed as a numpy_ array.

Introduction.html
    We created an image list (alternativly: stack), initially empty.
    ..at the first image position in the list; this position has an index number of zero.
    The output command typically copies all images in the list to a like set of output files. ..Generally, though, image lists contain many items, so G'MIC usually appends to the template name an identifying numeral, the position of the image in the list ensuring that all output files have unique names.
    Unadorned, pipeline commands operate on all images on a list, though right hand side command decorations limit the scope to various subsets of the list.
    When an image moves onto the list or is output, G'MIC reports its shape using four dimensions.
        width
        height of an image
        considers depth, also measured in pixels (This dimension can represent time)
        the number of channels in each pixel. (RGBA, CMYK...)

    There are additional details about G'MIC language which are worth knowing sooner rather than later and these will be taken up in the following sections.
        1.	Images
        2.	Selections
        3.	Math
        4.	Beginner's Cookbook
        5.	Command guide


Images.html
    Commonly, these are the red, green, blue and transparency components of an image, but G'MIC does not impose this or any other  interpretation on the spectral dimension.
    Internally, G'MIC calculates with with thirty-two bit floating point data.
    the depth of an image and the rescaling of its data to an apt range for the target file format.
        (TIFF) has a concept of pages; each slice will go on a separate page
        Portable Network Graphics, among others), then you will need to split any image with more than one slice along the z (depth) axis.
            This will replace the one image with multiple slices a set of single-sliced images.
            In writing these and other images on the image list, G'MIC will employ a series of numbered files,
                foo-000000.png, foo-000001.png, …, one for each item on the image list,
                to ensure that all items on the G'MIC image list have a unique output file name.
    The dynamic range of floating point numerals is wider than most integer file formats.
    employing G'MIC's native .cimg format, which will accommodate images of arbitrary depth, width, height, spectral length and number format.

Selections and Other Decorations.html
    image list, aka the stack
    image indices, reflecting images' positions on the stack.
    These indices start from zero and increment by one.
    Image Selection
        G'MIC recognizes decorations on a command's right hand side.
        appear in square brackets immediately to the right of the command
        Selections contain collections of image indices
            direct references: …noise[0] 0.5,2 blur[2] 10 diffusiontensors[–1,4] 0,1,0.7,2.3…
                fictive command:
                    Everything	-foo
                    Left Single     -foo[n]
                    Right Single    -foo[–n]
                    Enumerated      -foo[a,–b,…z]
                    Range           -foo[a-b]
                    Relative Range	  -foo[a%-b%]
                    Modulo n        -foo[&lt;Range&gt;:n]
                    Except	         -foo[^&lt;selection&gt;]
            indirect references coupling through names
                    Names	            -foo[&lt;label&gt;]
                    Enumerated Names    -foo[&lt;label-1&gt;,…]
        This collection behaves like a set.


Mathematical Expressions.html
    mathematical expressions operate with reference images.














</t>
<t tx="albercio2.20240212174045.1"></t>
<t tx="albercio2.20240212174732.1">&lt;&lt; import &gt;&gt;

@others

@language python
@tabwidth -4</t>
<t tx="albercio2.20240212174732.2">from .comfy_gmic import NODE_CLASS_MAPPINGS, NODE_DISPLAY_NAME_MAPPINGS
__all__ = ['NODE_CLASS_MAPPINGS', 'NODE_DISPLAY_NAME_MAPPINGS']</t>
<t tx="albercio2.20240212174846.1">&lt;&lt; import &gt;&gt;


@others
@language python
@tabwidth -4
</t>
<t tx="albercio2.20240212174846.2">import random
import shlex
import subprocess
from pathlib import Path

import folder_paths
from nodes import LoadImage, SaveImage
</t>
<t tx="albercio2.20240212174846.3">class GmicCliWrapper:

    def __init__(self):
        self.output_dir = folder_paths.get_temp_directory()
        self.type = "temp"
        self.prefix_append = "_temp_" + ''.join(
            random.choice("abcdefghijklmnopqrstupvxyz") for x in range(5))

    @others


</t>
<t tx="albercio2.20240212174846.4">@classmethod
def INPUT_TYPES(s):
    return {
        "required": {
            "command": ("STRING", {
                "multiline": False
            }),
            "images": ("IMAGE", ),
        }
    }
</t>
<t tx="albercio2.20240212174846.5">
RETURN_TYPES = ("IMAGE", )
FUNCTION = "gmic_filter"
CATEGORY = "filters"

</t>
<t tx="albercio2.20240212174846.6">def gmic_filter(self, command, images):
    self.compress_level = 4
    imgtemp = SaveImage.save_images(self, images)
    fname = imgtemp['ui']['images'][0]['filename']
    temp_dir = Path(self.output_dir)
    inpath = temp_dir / fname
    outpath = temp_dir / fname.replace('.png', '-out.png')
    try:
        autodash = "" if command.startswith(('-', '+')) else "-"
        gmic_command_args = shlex.split(autodash + command)
        subprocess.check_call([
            'gmic',
            '-input',
            inpath,
        ] + gmic_command_args + [
            '-output',
            outpath,
        ])
        result_image = LoadImage.load_image(self, str(outpath))
    finally:
        if outpath.exists():
            outpath.unlink()
        if inpath.exists():
            inpath.unlink()

    return (result_image[0], )
</t>
<t tx="albercio2.20240212174846.7">NODE_CLASS_MAPPINGS = {
    "GmicCliWrapper": GmicCliWrapper,
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "GmicCliWrapper": "GMIC Image Processing",
}
</t>
<t tx="albercio2.20240216135810.1">

Rename GMICQt node
    features?
        batch images
        FiltersParser
        to numpy / torch tensor arrays

Make GMICCli node
    python sanitize command?
    features?
        all GMICQT features
        gmic file process
        CImg file process

Filter ID for easier visual comparing on filename
    filter_id = command.split(" ")[0]

--



Documentation as tutorial:
    Riffs
    Finger Exercise

Unit Tests
    cli
    qt

--

Cli Safety
Cross platform</t>
<t tx="albercio2.20240216135957.1"></t>
<t tx="albercio2.20240216140122.1">
13de815
    compress_level fix and other improvements
        rewrite: safer shell command; better tempfile cleanup
            Use pathlib.Path to reduce the os.path... clutter.
            Don't put the user command, unescaped, into a shell. Special characters
            (e.g. "; rm -rf ~;") could lead to surprises, and getting quoting right
            on longer commands was tricky
        cross-platform path join
        don't prepend command with '-' if it already has one (or a '+')
        workaround for SaveImage having self.compress_level now
        autoformat








</t>
<t tx="albercio2.20240216184208.1">@ignore
@nosearch
</t>
<t tx="albercio2.20240216184208.19"></t>
<t tx="albercio2.20240216184208.2">@ignore
@nosearch
@language patch
--- 7548ef2
+++ main
@@ -1,51 +1,61 @@
-import os
-import io
 import random
-import tempfile
-from PIL import Image
+import shlex
+import subprocess
+from pathlib import Path
+
+import folder_paths
 from nodes import LoadImage, SaveImage
-import folder_paths
 
 
 class GmicCliWrapper:
+
     def __init__(self):
         self.output_dir = folder_paths.get_temp_directory()
         self.type = "temp"
-        self.prefix_append = "_temp_" + ''.join(random.choice("abcdefghijklmnopqrstupvxyz") for x in range(5))
+        self.prefix_append = "_temp_" + ''.join(
+            random.choice("abcdefghijklmnopqrstupvxyz") for x in range(5))
+
     @classmethod
     def INPUT_TYPES(s):
         return {
             "required": {
-                "command": ("STRING", {"multiline": False}),
+                "command": ("STRING", {
+                    "multiline": False
+                }),
                 "images": ("IMAGE", ),
             }
         }
-    RETURN_TYPES = ("IMAGE",)
+
+    RETURN_TYPES = ("IMAGE", )
     FUNCTION = "gmic_filter"
     CATEGORY = "filters"
+
     def gmic_filter(self, command, images):
+        self.compress_level = 4
         imgtemp = SaveImage.save_images(self, images)
         fname = imgtemp['ui']['images'][0]['filename']
-        inpath = "{}\{}".format(self.output_dir,fname )
+        temp_dir = Path(self.output_dir)
+        inpath = temp_dir / fname
+        outpath = temp_dir / fname.replace('.png', '-out.png')
+        try:
+            autodash = "" if command.startswith(('-', '+')) else "-"
+            gmic_command_args = shlex.split(autodash + command)
+            subprocess.check_call([
+                'gmic',
+                '-input',
+                inpath,
+            ] + gmic_command_args + [
+                '-output',
+                outpath,
+            ])
+            result_image = LoadImage.load_image(self, str(outpath))
+        finally:
+            if outpath.exists():
+                outpath.unlink()
+            if inpath.exists():
+                inpath.unlink()
 
-        filter_id = command.split(" ")[0]
-        fd, outpath = tempfile.mkstemp(prefix="GMIC--{}".format(filter_id),
-                                    suffix=".png",
-                                    dir=None,)
-
-        gmic_cli_command = 'gmic -input {} -{} -output "{}"'.format(inpath, command, outpath)
-        os.system(gmic_cli_command)
-
-
-
-        image3 = LoadImage.load_image(self, outpath)
-
-
-        return (image3[0],)
-
-
-
-
+        return (result_image[0], )
 
 
 NODE_CLASS_MAPPINGS = {
@@ -55,4 +65,3 @@
 NODE_DISPLAY_NAME_MAPPINGS = {
     "GmicCliWrapper": "GMIC Image Processing",
 }
-
@language plain
</t>
<t tx="albercio2.20240216184208.20">@ignore
@nosearch
@language patch
--- 7548ef2
+++ main
@@ -1,7 +1,7 @@
-import os
-import io
 import random
-import tempfile
-from PIL import Image
+import shlex
+import subprocess
+from pathlib import Path
+
+import folder_paths
 from nodes import LoadImage, SaveImage
-import folder_paths
@language plain
</t>
<t tx="albercio2.20240216184208.21">import os
import io
import random
import tempfile
from PIL import Image
from nodes import LoadImage, SaveImage
import folder_paths
</t>
<t tx="albercio2.20240216184208.22">@ignore
@nosearch
@language patch
--- 7548ef2
+++ main
@@ -1,8 +1,11 @@
 class GmicCliWrapper:
+
     def __init__(self):
         self.output_dir = folder_paths.get_temp_directory()
         self.type = "temp"
-        self.prefix_append = "_temp_" + ''.join(random.choice("abcdefghijklmnopqrstupvxyz") for x in range(5))
+        self.prefix_append = "_temp_" + ''.join(
+            random.choice("abcdefghijklmnopqrstupvxyz") for x in range(5))
+
     @others
 
 
@language plain
</t>
<t tx="albercio2.20240216184208.23">class GmicCliWrapper:
    def __init__(self):
        self.output_dir = folder_paths.get_temp_directory()
        self.type = "temp"
        self.prefix_append = "_temp_" + ''.join(random.choice("abcdefghijklmnopqrstupvxyz") for x in range(5))
    @others


</t>
<t tx="albercio2.20240216184208.24">@ignore
@nosearch
@language patch
--- 7548ef2
+++ main
@@ -2,7 +2,9 @@
 def INPUT_TYPES(s):
     return {
         "required": {
-            "command": ("STRING", {"multiline": False}),
+            "command": ("STRING", {
+                "multiline": False
+            }),
             "images": ("IMAGE", ),
         }
     }
@language plain
</t>
<t tx="albercio2.20240216184208.25">@classmethod
def INPUT_TYPES(s):
    return {
        "required": {
            "command": ("STRING", {"multiline": False}),
            "images": ("IMAGE", ),
        }
    }
</t>
<t tx="albercio2.20240216184208.26">@ignore
@nosearch
@language patch
--- 7548ef2
+++ main
@@ -1,3 +1,5 @@
-RETURN_TYPES = ("IMAGE",)
+
+RETURN_TYPES = ("IMAGE", )
 FUNCTION = "gmic_filter"
 CATEGORY = "filters"
+
@language plain
</t>
<t tx="albercio2.20240216184208.27">RETURN_TYPES = ("IMAGE",)
FUNCTION = "gmic_filter"
CATEGORY = "filters"
</t>
<t tx="albercio2.20240216184208.28">@ignore
@nosearch
@language patch
--- 7548ef2
+++ main
@@ -1,23 +1,26 @@
 def gmic_filter(self, command, images):
+    self.compress_level = 4
     imgtemp = SaveImage.save_images(self, images)
     fname = imgtemp['ui']['images'][0]['filename']
-    inpath = "{}\{}".format(self.output_dir,fname )
+    temp_dir = Path(self.output_dir)
+    inpath = temp_dir / fname
+    outpath = temp_dir / fname.replace('.png', '-out.png')
+    try:
+        autodash = "" if command.startswith(('-', '+')) else "-"
+        gmic_command_args = shlex.split(autodash + command)
+        subprocess.check_call([
+            'gmic',
+            '-input',
+            inpath,
+        ] + gmic_command_args + [
+            '-output',
+            outpath,
+        ])
+        result_image = LoadImage.load_image(self, str(outpath))
+    finally:
+        if outpath.exists():
+            outpath.unlink()
+        if inpath.exists():
+            inpath.unlink()
 
-    filter_id = command.split(" ")[0]
-    fd, outpath = tempfile.mkstemp(prefix="GMIC--{}".format(filter_id),
-                                suffix=".png",
-                                dir=None,)
-
-    gmic_cli_command = 'gmic -input {} -{} -output "{}"'.format(inpath, command, outpath)
-    os.system(gmic_cli_command)
-
-
-
-    image3 = LoadImage.load_image(self, outpath)
-
-
-    return (image3[0],)
-
-
-
-
+    return (result_image[0], )
@language plain
</t>
<t tx="albercio2.20240216184208.29">def gmic_filter(self, command, images):
    imgtemp = SaveImage.save_images(self, images)
    fname = imgtemp['ui']['images'][0]['filename']
    inpath = "{}\{}".format(self.output_dir,fname )

    filter_id = command.split(" ")[0]
    fd, outpath = tempfile.mkstemp(prefix="GMIC--{}".format(filter_id),
                                suffix=".png",
                                dir=None,)

    gmic_cli_command = 'gmic -input {} -{} -output "{}"'.format(inpath, command, outpath)
    os.system(gmic_cli_command)



    image3 = LoadImage.load_image(self, outpath)


    return (image3[0],)




</t>
<t tx="albercio2.20240216184208.30">@ignore
@nosearch
@language patch
--- 7548ef2
+++ main
@@ -5,4 +5,3 @@
 NODE_DISPLAY_NAME_MAPPINGS = {
     "GmicCliWrapper": "GMIC Image Processing",
 }
-
@language plain
</t>
<t tx="albercio2.20240216184208.31">NODE_CLASS_MAPPINGS = {
    "GmicCliWrapper": GmicCliWrapper,
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "GmicCliWrapper": "GMIC Image Processing",
}

</t>
</tnodes>
</leo_file>
